// Each #kernel tells which function to compile; you can have many kernels
#define CLEAR_GRID_THREAD_COUNT 8
#define RIGID_BODY_THREAD_COUNT 8
#define PARTICLE_THREAD_COUNT 8

#include "includes/Quaternion.cginc"

// Kernels
// Per Rigid Body	0
#pragma kernel GenerateParticleValues

// Per Grid Cell	1
#pragma kernel ClearGrid

// Per Particle		2
#pragma kernel PopulateGrid

// Per Particle		3
#pragma kernel CollisionDetection

// Per Rigid Body	4
#pragma kernel ComputeMomenta

// Per Rigid Body	5
#pragma kernel ComputePositionAndRotation


// Buffers
// voxelCollisionGrid				(RWStructuredBuffer<int4>)


// Constants
// gridStartPosition				(float3) // lower left bound
// gridDimensions 					(int3)
// gridMax							(int) gridDimensions.x * gridDimensions.y * gridDimensions.z * 4
// particleDiameter 				(float)
// springCoefficient 				(float) (negative) (Equation 10)
// dampingCoefficient 				(float) (Equation 11)
// tangentialCoefficient 			(float) (Equation 12)
struct RigidBody
{
	float3 position;
	float4 quaternion;
	float3 velocity;
	float3 angularVelocity;
	int particleIndex;
	int particleCount;
};

struct Particle
{
	float3 position;
	float3 velocity;
	float3 force;
	float3 localPosition;
	float3 offsetPosition;
};

shared RWStructuredBuffer<RigidBody> rigidBodiesBuffer;
shared RWStructuredBuffer<Particle> particlesBuffer;

int particlesPerRigidBody;
float deltaTime;
float particleMass;
float3x3 inertialTensor;
float3x3 inverseInertialTensor;


//////////////////////////////
// Generate Particle Values //
//////////////////////////////
// Per Rigid Body
// Use rigidBody positions and 
// rigidBodyQuaternions to
// Generate particle positions
// and particle offsetPositions
// and particle velocities
//
//////////////////////////////


float3 rotateVectorByQuaternion(float4 quaternion, float3 vec)
{
	return quat_mul(quaternion, vec);
}

[numthreads(RIGID_BODY_THREAD_COUNT,1,1)]
void GenerateParticleValues (uint3 id : SV_DispatchThreadID)
{
	RigidBody body = rigidBodiesBuffer[id.x];
	int index = body.particleIndex;

	for (int i=0; i < body.particleCount; i++){
		Particle particle = particlesBuffer[index];
		particle.offsetPosition = quat_mul(body.quaternion, particle.localPosition);
		particle.position = body.position + particle.offsetPosition;
		particle.velocity = body.velocity + cross(body.angularVelocity, particle.offsetPosition);
		particlesBuffer[index] = particle;

		//Until I've update the particles code
		//int p_id = index;
		//particleRelativePositions[p_id] = rotateVectorByQuaternion(body.quaternion, particleInitialRelativePositions[p_id]);
		//particlePositions[p_id] = body.position + particleRelativePositions[p_id];
		//particleVelocities[p_id] = body.velocity + cross(body.angularVelocity, particleRelativePositions[p_id]);
		//End deletable section

		index++;
    }
}


//////////////////////
// Grid Generation //
/////////////////////
// Per Grid Cell
// Use particlePositions
// to populate the
// voxelCollisionGrid
// Input
// StructuredBuffer<float3> particlePositions; (defined above)
int3 gridDimensions;
float3 gridStartPosition;
int gridMax; // gridDimensions.x * gridDimensions.y * gridDimensions.z
float particleDiameter;
// Output
RWStructuredBuffer<int4> voxelCollisionGrid;
// DEBUG ONLY
//RWStructuredBuffer<int3> debugParticleVoxelPositions;
[numthreads(CLEAR_GRID_THREAD_COUNT,1,1)]
void ClearGrid (uint3 id : SV_DispatchThreadID)
{
	voxelCollisionGrid[id.x].r = -1;
	voxelCollisionGrid[id.x].g = -1;
	voxelCollisionGrid[id.x].b = -1;
	voxelCollisionGrid[id.x].a = -1;
}

// Returns the grid index for particle p
// equivalent to _gridIndexFromThree(_gridIndexThree(p_id))
int _gridIndex(int id) {
	int3 gridLocation = (particlesBuffer[id].position - gridStartPosition) / particleDiameter;
	// DEBUG ONLY
	//debugParticleVoxelPositions[p_id] = gridLocation;
	//debugParticleVoxelPositions[p_id] = int3(1,2,3);
	return gridLocation.x + gridDimensions.x * gridLocation.y + (gridDimensions.x * gridDimensions.y * gridLocation.z);
}

[numthreads(PARTICLE_THREAD_COUNT,1,1)]
void PopulateGrid (uint3 id : SV_DispatchThreadID)
{
	int p_id = id.x;
	int gridIndex = _gridIndex(p_id);
	// clamp gridIndex?
	if (gridIndex < gridMax && gridIndex > -1)
	{
		int originalValue = 0;
		InterlockedCompareExchange(voxelCollisionGrid[gridIndex].x, -1, p_id, originalValue);
		if (originalValue != -1)
			InterlockedCompareExchange(voxelCollisionGrid[gridIndex].y, -1, p_id, originalValue);
		if (originalValue != -1)
			InterlockedCompareExchange(voxelCollisionGrid[gridIndex].z, -1, p_id, originalValue);
		if (originalValue != -1)
			InterlockedCompareExchange(voxelCollisionGrid[gridIndex].w, -1, p_id, originalValue);
	}
}

/////////////////////////
// Collision Detection //
/////////////////////////
// Per Particle
// Use particle positions, grid and velocity to compute Particle force
// Input
// StructuredBuffer<float3> particlesBuffer;
// RWStructuredBuffer<int4> voxelCollisionGrid; (defined in Grid Generation)
float springCoefficient;
float dampingCoefficient;
float tangentialCoefficient;
// Output
//RWStructuredBuffer<float3> particleForces;
float3 _collisionReaction(int j_id, int i_id)
{
	// the force on particle i after colliding with particle j is modelled as follows

	Particle particleJ = particlesBuffer[j_id];
	Particle particleI = particlesBuffer[i_id];

	float3 relativePosition = particleJ.position - particleI.position; // position of j relative to i
	float relativePositionMagnitude = length(relativePosition);

	if (relativePositionMagnitude < particleDiameter)
	{
		float3 relativePositionNormalized = relativePosition / relativePositionMagnitude;

		// repulsive force (Equation 10)
		float3 repulsiveForce = -springCoefficient * (particleDiameter - relativePositionMagnitude) * relativePositionNormalized;
		// damping force (Equation 11)
		// https://www2.msm.ctw.utwente.nl/sluding/PAPERS/luding_alert2008.pdf 
		// says that the damping force acts along the normal....
		// not sure whether relativeVelocity is relative to particle i's position or particle i's velocity
		// using velocity here
		float3 relativeVelocity = particleJ.velocity - particleI.velocity; // not sure if correct
		float3 dampingForce = dampingCoefficient * relativeVelocity;

		// tangential force (Equation 12)
		float3 tangentialVelocity = relativeVelocity - (dot(relativeVelocity, relativePositionNormalized) * relativePositionNormalized);
		float3 tangentialForce = tangentialCoefficient * tangentialVelocity;

		return repulsiveForce + dampingForce + tangentialForce;
	}

	return float3(0,0,0);
}

float3 _collisionReactionWithGround(int id) {
	Particle particle = particlesBuffer[id];

	float3 groundParticlePosition = particle.position;
	groundParticlePosition.y = -particleDiameter*0.5;


	float3 relativePosition = groundParticlePosition - particle.position; // position of j relative to i
	float relativePositionMagnitude = length(relativePosition);

	if (relativePositionMagnitude < particleDiameter)
	{
		float3 relativePositionNormalized = relativePosition / relativePositionMagnitude;

		// repulsive force (Equation 10)
		float3 repulsiveForce = -springCoefficient * (particleDiameter - relativePositionMagnitude) * relativePositionNormalized;
		// damping force (Equation 11)
		// https://www2.msm.ctw.utwente.nl/sluding/PAPERS/luding_alert2008.pdf 
		// says that the damping force acts along the normal....
		// not sure whether relativeVelocity is relative to particle i's position or particle i's velocity
		// using velocity here

		float3 relativeVelocity = float3(0.0f,0.0f,0.0f) - particle.velocity; // not sure if correct
		float3 dampingForce = dampingCoefficient * relativeVelocity;

		// tangential force (Equation 12)
		float3 tangentialVelocity = relativeVelocity - (dot(relativeVelocity, relativePositionNormalized) * relativePositionNormalized);
		float3 tangentialForce = tangentialCoefficient * tangentialVelocity;

		return repulsiveForce + dampingForce + tangentialForce;

	}

	return float3(0.0f,0.0f,0.0f);
}

// Returns the grid location for particle p
int3 _gridIndexThree(int id) {
	return (particlesBuffer[id].position - gridStartPosition) / particleDiameter;
}

// Converts a grid location to a grid index
int _gridIndexFromThree(int x, int y, int z) {
	return x + (gridDimensions.x * y) + (gridDimensions.x * gridDimensions.y * z);
}

// checks cell x,y,z for collision with i, calls _collisionreaction if so
float3 _checkGridCell(int i, int x, int y, int z) {
	float3 force = float3(0,0,0);
	if (x > -1 && y > -1 && z > -1 && x < gridDimensions.x && y < gridDimensions.y && z < gridDimensions.z) {
		int g_index = _gridIndexFromThree(x,y,z);
		if (g_index < gridMax) {
			int j = voxelCollisionGrid[g_index].x;
			if (j > -1 && j != i)
				force += _collisionReaction(j, i);

			j = voxelCollisionGrid[g_index].y;
			if (j > -1 && j != i)
				force +=_collisionReaction(j, i);

			j = voxelCollisionGrid[g_index].z;
			if (j > -1 && j != i)
				force += _collisionReaction(j, i);
			
			j = voxelCollisionGrid[g_index].w;
			if (j > -1  && j != i)
				force += _collisionReaction(j, i);
		}
	}
	return force;
}

float gravityCoefficient;
[numthreads(PARTICLE_THREAD_COUNT,1,1)]
void CollisionDetection (uint3 id : SV_DispatchThreadID)
{
	int i = id.x;
	int3 i_gridLocation = _gridIndexThree(i);
	float3 force = float3(0,0,0);
	force += _checkGridCell(i, i_gridLocation.x, 	i_gridLocation.y, 		i_gridLocation.z);
	force += _checkGridCell(i, i_gridLocation.x, 	i_gridLocation.y, 		i_gridLocation.z+1);
	force += _checkGridCell(i, i_gridLocation.x, 	i_gridLocation.y, 		i_gridLocation.z-1);
	force += _checkGridCell(i, i_gridLocation.x, 	i_gridLocation.y+1, 	i_gridLocation.z);
	force += _checkGridCell(i, i_gridLocation.x, 	i_gridLocation.y+1, 	i_gridLocation.z+1);
	force += _checkGridCell(i, i_gridLocation.x, 	i_gridLocation.y+1, 	i_gridLocation.z-1);
	force += _checkGridCell(i, i_gridLocation.x, 	i_gridLocation.y-1, 	i_gridLocation.z);
	force += _checkGridCell(i, i_gridLocation.x, 	i_gridLocation.y-1, 	i_gridLocation.z+1);
	force += _checkGridCell(i, i_gridLocation.x, 	i_gridLocation.y-1, 	i_gridLocation.z-1);

	force += _checkGridCell(i, i_gridLocation.x-1, 	i_gridLocation.y, 		i_gridLocation.z);
	force += _checkGridCell(i, i_gridLocation.x-1, 	i_gridLocation.y, 		i_gridLocation.z+1);
	force += _checkGridCell(i, i_gridLocation.x-1, 	i_gridLocation.y, 		i_gridLocation.z-1);
	force += _checkGridCell(i, i_gridLocation.x-1, 	i_gridLocation.y+1, 	i_gridLocation.z);
	force += _checkGridCell(i, i_gridLocation.x-1, 	i_gridLocation.y+1, 	i_gridLocation.z+1);
	force += _checkGridCell(i, i_gridLocation.x-1, 	i_gridLocation.y+1, 	i_gridLocation.z-1);
	force += _checkGridCell(i, i_gridLocation.x-1, 	i_gridLocation.y-1, 	i_gridLocation.z);
	force += _checkGridCell(i, i_gridLocation.x-1, 	i_gridLocation.y-1, 	i_gridLocation.z+1);
	force += _checkGridCell(i, i_gridLocation.x-1, 	i_gridLocation.y-1, 	i_gridLocation.z-1);

	force += _checkGridCell(i, i_gridLocation.x+1, 	i_gridLocation.y, 		i_gridLocation.z);
	force += _checkGridCell(i, i_gridLocation.x+1, 	i_gridLocation.y, 		i_gridLocation.z+1);
	force += _checkGridCell(i, i_gridLocation.x+1, 	i_gridLocation.y, 		i_gridLocation.z-1);
	force += _checkGridCell(i, i_gridLocation.x+1, 	i_gridLocation.y+1, 	i_gridLocation.z);
	force += _checkGridCell(i, i_gridLocation.x+1, 	i_gridLocation.y+1, 	i_gridLocation.z+1);
	force += _checkGridCell(i, i_gridLocation.x+1, 	i_gridLocation.y+1, 	i_gridLocation.z-1);
	force += _checkGridCell(i, i_gridLocation.x+1, 	i_gridLocation.y-1, 	i_gridLocation.z);
	force += _checkGridCell(i, i_gridLocation.x+1, 	i_gridLocation.y-1, 	i_gridLocation.z+1);
	force += _checkGridCell(i, i_gridLocation.x+1, 	i_gridLocation.y-1, 	i_gridLocation.z-1);
	
	force.y -= gravityCoefficient;
	force += _collisionReactionWithGround(i);

	particlesBuffer[i].force = force;
}

////////////////////////////
// Computation Of Momenta //
////////////////////////////
// Per RigidBdy
// Use particleForces to compute the force and angular force on the rigid body
// Input
// RWStructuredBuffer<Particle> particlesBuffer;

float frictionCoefficient;
float angularFrictionCoefficient;
float angularForceScalar;
float linearForceScalar;
// Output
//RWStructuredBuffer<RigidBody> rigidBodiesBuffer;

[numthreads(RIGID_BODY_THREAD_COUNT,1,1)]
void ComputeMomenta (uint3 id : SV_DispatchThreadID)
{
	float3 relativePosition 	= float3(0,0,0);
	float3 linearForce 			= float3(0,0,0);
	float3 angularForce 		= float3(0,0,0);

	RigidBody body = rigidBodiesBuffer[id.x];

	for (int i = 0; i < body.particleCount; i++) 
	{
		Particle particle = particlesBuffer[body.particleIndex + i];
		relativePosition 			= particle.offsetPosition;
		linearForce 				+= particle.force;
		angularForce 				+= cross(relativePosition, particle.force);	
	}

	float threshold = 1.0 / pow(10.0,6);

	float cubeMass = particleMass * body.particleCount;
	body.velocity /= 1.0 + deltaTime*frictionCoefficient;
	body.velocity += linearForceScalar * deltaTime * linearForce/cubeMass;
	if (length(body.velocity) < threshold) {
		body.velocity = 0;
	}

	// new rotation
	body.angularVelocity /= 1.0 + deltaTime*angularFrictionCoefficient;
	body.angularVelocity += angularForceScalar * deltaTime * angularForce; // probably wrong
	if (length(body.angularVelocity) < threshold) {
		body.angularVelocity = 0;
	}

	rigidBodiesBuffer[id.x] = body;
}

/////////////////////////////
// Computation Of Position //
/////////////////////////////
// Per RigidBody
// Use rigidBodyForce and rigidBodyTorque to compute the rigid body position and rotation.
//RWStructuredBuffer<float3x3> inverseInertialMatrices;
[numthreads(RIGID_BODY_THREAD_COUNT,1,1)]
void ComputePositionAndRotation (uint3 id : SV_DispatchThreadID)
{
	RigidBody body = rigidBodiesBuffer[id.x];
	body.position += body.velocity * deltaTime;

	float4 omega = float4(body.angularVelocity, 0);
	body.quaternion = normalize(body.quaternion + deltaTime * (0.5*quat_concat(omega, body.quaternion)));

	rigidBodiesBuffer[id.x] = body;

}
