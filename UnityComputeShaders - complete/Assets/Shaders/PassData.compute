// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Clear
#pragma kernel Circles

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
float4 clearColor;
float4 circleColor;
int texResolution;

/*Returns pseudo random number in range 0 <= x < 1 */
float random(float value, float seed = 0.546){
	float random = (frac(sin(value + seed) * 143758.5453) + 1.0)/2.0;
	return random;
}

float2 random2(float value){
	return float2(
		random(value, 3.9812),
		random(value, 7.1536)
	);
}

void plot1( int x, int y){
    Result[uint2(x, y)] = circleColor;
}

void plot8( int x, int y, int2 centre ) {
	plot1( centre.x + x, centre.y + y ); plot1( centre.x - x, centre.y + y );
	plot1( centre.x + x, centre.y - y ); plot1( centre.x - x, centre.y - y );
	plot1( centre.y + y, centre.x + x ); plot1( centre.y - y, centre.x + x );
	plot1( centre.y + y, centre.y - x ); plot1( centre.y - y, centre.x - x );
}

void drawCircle( int2 centre, int radius ) {
	int rs2 = radius*radius*4; 
	int xs2 = 0;
	int ys2m1 = rs2 - 2*radius + 1;
	int x = 0;
	int y = radius;
	int ycs2;
	plot8( x, y, centre );
	while( x <= y ) {
		/* advance to the right */
		xs2 = xs2 + 8*x + 4;
		++x;
		/* calculate new Yc */
		ycs2 = rs2 - xs2;
		if( ycs2 < ys2m1 ) {
			ys2m1 = ys2m1 - 8*y + 4;
			--y;
		}
		plot8( x, y, centre );
	}
}

[numthreads(8,8,1)]
void Clear (uint3 id : SV_DispatchThreadID)
{
     Result[id.xy] = clearColor;
}

[numthreads(32,1,1)]
void Circles (uint3 id : SV_DispatchThreadID)
{
	int2 centre = (int2)(random2((float)id.x) * (float)texResolution);
	int radius = (int)(random((float)id.x) * ((float)texResolution/10));

	drawCircle( centre, radius );
}


