#pragma kernel CSMain
#define GROUP_SIZE 256

struct Boid
{
	float3 position;
	float3 direction;
};

RWStructuredBuffer<Boid> boidsBuffer;

float time;
float deltaTime;
float rotationSpeed;
float boidSpeed;
float boidSpeedVariation;
float3 flockPosition;
float neighbourDistance;
int boidsCount;

[numthreads(GROUP_SIZE,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	Boid boid = boidsBuffer[id.x];

	//float3 pos = boid.position;
	//float3 rot = boid.direction;

	float3 separation = float3(0, 0.0, 0);
	float3 alignment = float3(0.0, 0.0, 0.0);
	float3 cohesion = flockPosition;

	uint nearbyCount = 1; // Add self that is ignored in loop

	for (int i = 0; i < boidsCount; i++)
	{
		if (i != int(id.x))
		{
			Boid tempBoid = boidsBuffer[i];
			if (distance(boid.position, tempBoid.position) < neighbourDistance)
			{
				float3 diff = boid.position - tempBoid.position;
				float diffLen = length(diff);
				float scaler = clamp(1.0 - diffLen / neighbourDistance, 0.0, 1.0);
				separation += diff * (scaler / diffLen);
				
				alignment += tempBoid.direction;
				cohesion += tempBoid.position;
				nearbyCount++;
			}
		}
	}

	float avg = 1.0 / nearbyCount;
	alignment *= avg;
	cohesion *= avg;
	cohesion = normalize(cohesion - boid.position);

	float3 direction = alignment + separation + cohesion;

	float prop = 0.94;//exp(-rotationSpeed * deltaTime);//0.9-0.98
	boid.direction = lerp(direction, normalize(boid.direction), prop);
	boid.position += boid.direction * boidSpeed * deltaTime;

	boidsBuffer[id.x] = boid;
}


